package cn.edu.bupt.opensource.example;

/**
 * <p>Title: Command</p>
 * <p>Description: </p>
 * <p>Company: bupt.edu.cn</p>
 * <p>Created: 2018-06-27 15:05</p>
 * @author ChengTengfei
 * @version 1.0
 *
 * 命令模式
 *  定义：讲一个请求封装为一个对象，从而可使用不同的请求对客户进行参数化，请求排队、记录请求日志、及执行可撤销的操作。
 *  角色：
 *      1）Command：定义命令的接口。
 *      2）ConcreteCommand：命令接口实现对象，是“虚”的表现；通常持有接收者，调用接收者的功能完成命令的操作。
 *      3）Receiver：接收者，真正执行命令的对象。
 *      4）Invoker：命令调用者，要求命令对象执行请求，通常持有命令对象；与客户端直接交互，即使用命令对象的入口。
 *      5）Client：装配者，不是一般意义上的客户端；用于创建具体命令对象，并设置其接收者。
 *  举例：开机
 *      1）开机步骤：加载电源--->设备检查--->装载OS--->正常启动 谁来完成？如何完成？
 *      2）问题：客户端只发出请求或命令，而不关心真正的接收者、及具体实现；如何实现？
 *      3）抽象化：
 *          A.主板负责开机，相当于命令对象的接收者；
 *          B.开机按钮相当于命令，连接线相当于Client，机箱相当于Invoker。
 *  认识：
 *      1）关键：把请求封装成对象，即命令对象，并定义统一的操作接口，此命令可被存储、转发、记录、撤销；这个过程围绕着命令对象进行。
 *      2）命令模式的组装与调用：维护命令“虚”实现、真正实现(接收者)之间的关系。
                                在实际开发中，通常Client与Invoker融合在一起，即先组装，再调用Invoker。
 *      3）接收者：只需要真正执行命令即可，从Command实现类中转调执行。
 *      4）智能命令：不再需要接收者。
 *      5）请求发起对象与真正实现对象是解耦的。
 *      6）调用过程：
 *          A.组装命令对象、接收者对象
 *          B.触发调用Invoker，执行命令
 *      7）参数化配置：可使用不同的命令对象，去参数化配置客户的请求。
 *      8）可撤销的操作：放弃该操作，回到未执行前的状态；GUI的菜单是命令模式最典型的应用之一。
 *          A.补偿式(反操作式)     范例：计算器
 *          B.存储恢复式
 *      9）宏命令：包含多个命令的命令，即命令的组合。
 *      10）队列请求：对命令对象进行排队，组成一个工作队列，然后依次取出来执行；一般使用多线程、或线程池处理。
 *      11）日志请求：保存请求的历史记录；一般采用永久存储的方式。
 *          A.直接使用Java中的序列化方式，常用。
 *          B.在命令对象中，添加存储、装载的方法
 *  优点：
 *      1）松散耦合
 *      2）动态控制
 *      3）可自然地复合命令
 *      4）扩展性好
 *  本质：封装请求
 *  使用场景：
 *      1）若需要抽象出执行动态，并参数化对象，可考虑。
 *      2）在事务系统中，可考虑。命令模式的别名是Transaction。
 *      3）若支持取消操作、或系统崩溃后，支持重新执行命令，可考虑。
 *      4）在不同时刻指定、排列和执行请求，可考虑。
 *
 */
public interface Command {

    /**
     * 操作
     */
    void execute();

}
