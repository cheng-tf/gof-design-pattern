package cn.edu.bupt.opensource.example;

/**
 * <p>Title: Mediator</p>
 * <p>Description: 中介者，定义各个同事对象进行通信的接口 </p>
 * <p>Company: bupt.edu.cn</p>
 * <p>Created: 2018-06-26 16:57</p>
 * @author ChengTengfei
 * @version 1.0
 *
 * 中介者模式
 *  定义：使用一个中介对象封装一系列的对象交互；
 *      中介者使得个对象不再显示交互，从而宋丹耦合，且可独立地改变它们之间的交互。
 *  角色：
 *      1）Mediator：中介者接口，定义了各个同事之间需要交互的方法，可以为公共的、或小范围的。
 *      2）ConcreteMediator：具体的中介者实现对象，需要了解并维护各个同事对象，并负责具体协调它们之间的交互关系。
 *      3）Colleague：同事类(通常为抽象类)，负责约束同事对象的类型，并实现一些公共功能。
 *      4）ConcreteColleague：具体的同事类，实现自己的业务；与其他同事通过本身所持有的中介者进行通信。
 *  生活中的举例：若无主板，则各配件必须自行交互，极为复杂；类似于Java中的类耦合。
 *  举例：使用电脑看电影
 *  认识：
 *      1）功能：封装对象之间的交互；若一个对象的操作会引起其他对象的变化，可通知中介者并交付处理。
 *      2）需要Mediator接口吗？取决于是否需要提供多个中介者的实现；若仅有一个，可以不定义。
 *      3）同事关系：要求继承相同的类，从某种角度是同一个类型，即兄弟对象。
 *      4）同事与中介者的关系：相互依赖。
 *      5）同事与中介者的通信
 *          A.在Mediator接口中，定义一个特殊的通知接口，作为通用的方法让各个同事类调用。
 *          B.采用观察者模式，将Mediator实现为观察者，同事类实现为Subject；当同事类改变时，会通知Mediator。
 *  广义中介者
 *      1）标准中介者所存在的困难：
 *          A.是否有必要为同事对象定义一个公共的父类？值得思考，实际开发中，很多交互的对象没有公共父类。
 *          B.是否需要中介者的接口？实际开发中，通常不需要，且通常实现成单例。
 *          C.同事类有必要持有Mediator吗？需要知道中介者，但是否有必要作为属性注入，强依赖？在方法中去调用单例的中介者。
 *          D.中介者是否有必要持有所有的同事类？在处理方法中，去创建、获取、或从参数传入所需的同事对象
 *          E.中介者对象只是提供一个公共方法，来接受同事对象的通知吗？必须区分哪个同事对象、且了解业务变化。
 *      2）实际开发中的简化改进(广义中介者)
 *          A.去掉同事对象类的抽象父类，任意需要的对象均可成为同事；
 *          B.不定义Mediator接口，且具体的中介者对象实现为单例；
 *          C.同事对象不再持有中介者，仅在需要时直接获取调用；中介者不再持有同事对象，仅在具体处理方法中直接创建、获取、或参数传入
 *      3）举例：部门与人员
 *  优点：
 *      1）松散耦合
 *      2）集中控制交互
 *      3）多对多转化为一对多
 *  缺点：
 *      1）过度集中化，造成中介者复杂，难以管理。
 *  本质：封装交互
 *  适用场景：
 *      1）若一组对象的通信方式复杂，导致相互依赖、结构复杂，可考虑。
 *      2）若一个对象引用、并直接交互很多对象，导致该对象难以复用，可考虑。
 *
 */
public interface Mediator {

    /**
     *
     * @param colleague
     */
    void changed(Colleague colleague);


}
