package cn.edu.bupt.opensource.example;

/**
 * <p>Title: Observer</p>
 * <p>Description: 观察者接口 </p>
 * <p>Company: bupt.edu.cn</p>
 * <p>Created: 2018-06-27 11:16</p>
 * @author ChengTengfei
 * @version 1.0
 *
 * 观察者模式（发布-订阅模式）
 *  定义：定义对象间的一种一对多的依赖关系；但一个对象改变时，所有依赖于其的对象得到通知、并自动更新。
 *  角色：
 *      1）Subject：目标对象，可被多个观察者观察，提供对观察者注册、退订的维护；当其发生改变时，负责通知所有注册的、有效的观察者
 *      2）Observer：观察者接口，提供目标通知时对应的更新方法，进行相应的业务处理，
 *      3）ConcreteSubject：具体的目标对象实现，
 *      4）ConcreteObserver：具体的观察者实现
 *  生活中的举例：订阅报纸
 *      1）问题：何时能收到最新的报纸？
 *      2）抽象化：当一个对象的状态改变时，如何让依赖于其的所有对象得到通知，并进行相应的处理？
 *      3）使用观察者模式
 *  认识：
 *      1）目标对象与观察者的关系：一对多
 *          当然，一个观察者也可以观察多个目标对象，则在update()方法中应区分通知的目标来源；但通常是定义不同的回调方法。
 *      2）单向依赖：观察者依赖于目标对象（单向）；联系的主动权在于目标，观察者总是被动等待目标的通知。
 *      3）基本的实现：具体的目标对象维护观察者的注册信息，最简单的是使用集合，同事维护引起通知的状态。
 *                     具体的观察者可接收目标通知、及其传递的数据，
 *      4）命名建议：
 *          A.目标接口：名称 + Subject
 *          B.观察者接口：名称 + Observer
 *          C.观察者接口的更新方法：update
 *      5）触发通知的时机：状态维护完成后触发。
 *      6）相互观察：注意避免联动操作，引起死循环。
 *      7）通知顺序：平行，无先后次序。
 *  推模型与拉模型
 *      1）推模型：目标对象主动向观察者推送详细信息(通常为目标对象的全部/部分数据)，而无需关心观察者是否需要，相当于广播通信；
 *      2）拉模型：目标对象在通知时，仅传递少量数据，若观察者需要更具体的数据，则主动从目标对象中获取数据(拉数据)。
 *              这时，一般目标对象自身通常update形参传入。
 *      3）比较：
 *          A.推模型使得观察者难以复用，而拉模型不会。
 *  Java中的观察者模式
 *      1）java.util.Observable类：实现多数的目标功能，用于目标对象。
 *         java.util.Observer接口：具有update方法，用于观察者；同时支持推/拉模型。
 *      2）注意：
 *          A.状态改变必须调用this.setChanged()方法
 *  Swing中的观察者模式
 *      1）代表：事件处理
 *      2）理解：Swing组件是被观察的目标对象，每个实现监听器的类是观察者，监听器接口为观察者接口，addXXXListener()相当于注册监听器。
 *  优点：
 *      1）实现了观察者、目标之间的抽象耦合
 *      2）动态联动
 *      3）支持广播通信
 *  缺点：
 *      1）可能引起无谓的操作
 *  本质：触发联动
 *  适用场景：
 *      1）一个抽象模型具有两个方面，一个方面的操作依赖于另一个方面的状态变化，可考虑。
 *      2）若更改一个对象，需要连带改变其他对象，可考虑。
 *      3）当一个对象必须通知其他对象，而且又松散耦合，可考虑。
 *  简单变形实例：区别对待观察者
 *
 */
public interface Observer {

    /**
     * 更新方法
     * @param subject   目标对象，以获取其状态
     */
    void update(Subject subject);

}
