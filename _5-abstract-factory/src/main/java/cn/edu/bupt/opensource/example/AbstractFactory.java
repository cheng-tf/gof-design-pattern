package cn.edu.bupt.opensource.example;

/**
 * <p>Title: AbstractFactory</p>
 * <p>Description: </p>
 * <p>Company: bupt.edu.cn</p>
 * <p>Created: 2018-06-25 22:24</p>
 * @author ChengTengfei
 * @version 1.0
 *
 * 抽象工厂模式
 *  定义：提供一个创建一系列相关或相互依赖对象的接口，而无需指定具体的类。
 *  角色：
 *      1）AbstractFactory(抽象工厂)：定义创建一系列产品对象的操作接口。
 *      2）ConcreteFactory(具体工厂)：实现抽象工厂定义的方法，用于具体的创建。
 *      3）AbstractProduct：定义一系列产品对象的接口。
 *      4）ConcreteProduct：具体的产品实现对象；
 *          通常在具体工厂里，会选择具体的产品实现对象，来创建符合抽象工厂所定义的方法返回的产品类型的对象。
 *      5）Client(客户端)：使用抽象工厂获取一系列所需的产品对象，然后面向这些产品对象的接口编程。
 *  生活中的举例：选择组装电脑的配件，本例仅考虑CPU/主板
 *      1）装机工程师只负责组装，而客户负责选择装配所需要的具体配件。
 *      2）不用模式实现
 *          通过简单工厂解决了装机工程师只知道CPU/主板接口，而不知道具体实现的问题；
 *          但存在另一个问题：CPU对象与主板对象是有关联的，是需要相互匹配的！
 *      3）使用模式实现
 *          A.创建一个抽象工厂，定义抽象的创建CPU/主板的方法，相当于抽象的装机方案，但其中各个配件是相互匹配的，然后给装机工程师使用。
 *          B.每个客户端会提出自己的、或选择已有具体装机方案，相当于为抽象工厂提供了具体子类。
 *  认识：
 *      1）功能：为一系列相关、或相互依赖的对象差构建一个接口，抽象工厂其实是一个产品系列或产品簇。
 *      2）抽象成接口：AbstractFactory通常实现为接口。
 *      3）使用工厂方法：AbstractFactory定义的创建产品的方法可视为工厂方法，具体的实现延迟到具体工厂；即使用了工厂方法实现了抽象工厂。
 *      4）切换产品簇：切换时，提供不同的抽象工厂实现即可。
 *  定义可扩展的工厂
 *      1）问题：上述实现中，若在产品簇中新增一种产品，例如增加内存对象，
 *              则不仅需要在AbstractFactory添加创建内存的方法，同时所有的具体实现也要变化，非常不灵活。
 *      2）解决方法(不太安全)：在AbstractFactory中，只定义一个方法，并设置参数判断具体创建那个对象，返回值类型一般为Object类。
 *  DAO与抽象工厂
 *      1）DAO(数据访问对象)：JEE中的一个标准模式，
 *              用于解决一系列问题：数据源、存储类型、访问方式、供应商、版本的不同，这些不同造成访问数据的实现差异很大。
 *      2）功能：DAO可抽象、封装所有对数据的访问，承担与数据仓库交互的职责，即面临的所有问题在DAO内部解决。
 *      3）关系：在实现DAO时，最常见的策略是基于工厂策略，大多数通过抽象工厂模式实现，也可以结合工厂方法模式。
 *      4）DAO使用工厂方法模式实现：
 *      5）DAO使用抽象工厂模式实现：
 *  优点：
 *      1）分离接口与实现
 *      2）更易切换产品簇
 *  缺点：
 *      1）不太容易扩展新的产品
 *      2）易使得类层次复杂
 *  本质：选择产品簇/系列的实现
 *  适用场景：
 *      1）希望一个系统独立于其产品的创建、组合与表示，即只知道接口，而不关心实现。
 *      2）若一个系统由多个产品系列的一个进行配置，即可动态切换产品簇时，可考虑。
 *      3）强调一系列相关产品的接口，便于联合使用时，可考虑。
 */
public interface AbstractFactory {

    /**
     * 创建抽象产品A的对象
     */
    AbstractProductA createProductA();

    /**
     * 创建抽象产品B的对象
     */
    AbstractProductB createProductB();

}
