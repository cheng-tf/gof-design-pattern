package cn.edu.bupt.opensource.example;

/**
 * <p>Title: Proxy</p>
 * <p>Description: </p>
 * <p>Company: bupt.edu.cn</p>
 * <p>Created: 2018-06-26 18:49</p>
 * @author ChengTengfei
 * @version 1.0
 *
 * 代理模式
 *  定义：为其他对象体统一种代理，以控制对该对象的访问。
 *  角色：
 *      1）Proxy：代理对象，其功能如下：
 *          A.实现与具体目标对象相同的接口，便于该代理代替此对象；
 *          B.保存一个指向具体目标对象的引用，在需要时调用；
 *          C.可控制对具体目标对象的访问，并可能负责其创建、删除。
 *      2）Subject：目标接口，定义代理与具体目标对象的接口。
 *      3）RealSubject：具体的目标对象实现。
 *  举例：一次性访问多条数据
 *      1）HR管理应用：当选择部门或分公司，则显示所有员工的信息(仅名字)，且不分页，但当有必要查看具体信息时，也必须支持。
 *      2）不使用模式：
 *          当一次性访问多条数据时，且每条记录的数据量很大时。则消耗过多的内存。
 *      3）使用代理模式
 *          A.以时间换空间
 *          B.理论上，存在(1 + N)次查询。
 *          C.Lazy load：实现机制是动态代理。
 *  认识：
 *      1）功能：通过创建一个代理对象，用于代表真实的目标对象。
 *          对于客户端来说，直接访问代理对象；但实际上功能还是由真是的目标对象完成。即客户端--->代理--->真正的目标对象。
 *      2）分类：
 *          A.虚代理：根据需要来创建开销较大的对象，仅在被需要时才会真正创建。
 *          B.远程代理：即在不同的地址空间上代表同一个对象，最典型的是RMI技术。
 *          C.copy-on-write代理：在客户端操作时，仅在对象确实改变，才真正的拷贝/克隆一个目标对象，虚代理的一个分支。
 *          D.保护代理：控制对原始目标对象的访问；若有需要，赋予不同用户不同的访问权限。
 *          E.Cache代理：为昂贵的操作结果提供临时的存储空间，以便客户端共享。
 *          F.防火墙代理：保护不被恶意用户访问与操作。
 *          G.同步代理：多个用户同事访问目标对象而不引起冲突。
 *          H.智能指引：在访问对象时，执行一些附加操作。
 *          注意：在实际开发中，最常见的是虚代理、保护代理。及智能指引。
 *      3）代理与目标对象的关系
 *          若代理类通过接口来操作所代理的目标对象，则无需为每一个目标对象创建一个代理对象。
 *          而在虚代理中，一个具体目标类通常有一个代理类。
 *      4）保护代理：控制对原始对象进行访问的代理，用于对象具有不同的访问权限。
 *  Java中的代理
 *      1）静态代理：即前面自己实现的代理模式，
 *          缺点是若Subject接口发生变化，则代理与目标对象都需要变化，不灵活！
 *      2）动态代理：使用Java内建的对代理模式支持的功能来实现代理，其实是依赖于反射技术，动态生成类。
 *          与静态代理的区别是：动态代理类始终是有一个invoke()方法，当Subject接口变化时，此代理无需变化。
 *  优点：
 *      1）虚代理：根据需要创建一个“大”对象，加快运行速度，节省资源，用于对系统优化。
 *      2）保护代理：此代理可对目标对象进行功能增强，除权限控制外，还可以附加其他业务。
 *  本质：控制对象访问
 *  适用场景：
 *      1）当需要为一个对象在不同地址空间提供局部代表时，考虑远程代理。
 *      2）当按照需要创建开销很大的对象时，考虑虚代理。
 *      3）当控制对原始对象的访问时，考虑保护代理。
 *      4）当访问对象时执行附加操作时，考虑智能指引。
 *
 */
public class Proxy implements Subject {

    // 具体的目标对象实现
    private RealSubject realSubject;

    public Proxy(RealSubject realSubject) {
        this.realSubject = realSubject;
    }

    @Override
    public void request() {
        // 转调前的功能处理
        // 转调
        realSubject.request();
        // 转调后的功能处理
    }

}
