package cn.edu.bupt.opensource.example;

/**
 * <p>Title: Creator</p>
 * <p>Description: 创建器，声明工厂方法 </p>
 * <p>Company: bupt.edu.cn</p>
 * <p>Created: 2018-06-25 16:46</p>
 * @author ChengTengfei
 * @version 1.0
 *
 * 工厂方法模式
 *  定义：
 *      1）定义一个用于创建对象的接口，让子类决定实例化哪一个类，使得一个类的实例化延迟到其子类。
 *      2）简单工厂模式的抽象衍生：
 *          一个抽象的Factory类（可以是抽象类和接口），将不再负责具体的产品生产，而是只制定一些规范，具体的生产工作由其子类去完成。
 *          工厂类和产品类依次对应。即一个抽象工厂对应一个抽象产品，一个具体工厂对应一个具体产品，具体工厂负责生产对应的产品。
 *  角色：
 *      1）Creator(抽象工厂)：工厂方法模式的核心，创建器，声明工厂方法
 *      2）ConcreteCreator(具体工厂)：具体的创建器对象，覆盖实现Creator定义的工厂方法，返回具体的Product实例
 *      3）Product(抽象产品)：定义工厂方法所创建的对象的接口，即实际需要使用的对象的接口
 *      4）ConcreteProduct(具体产品)：具体的Product接口的实现对象
 *  举例：
 *      1）实现一个导出数据的应用框架，让客户端选择导出方式，并真正实现数据导出。
 *  认识：
 *      1）功能：让父类不知道具体实现的情况下，完成自身的功能调用，而具体的实现延迟到子类。
 *      2）实现成抽象类：即在工厂方法的实现中，父类通常是一个抽象类，包含创建所需对象的抽象方法（即工厂方法）！！！
 *      3）实现成具体类：通常在父类中提供获取所需对象的默认实现方法
 *      4）工厂方法的返回值：一般是被创建对象的接口对象
 *      5）谁来使用工厂方法创建的对象？
 *          A.Creator中的其他方法使用
 *          B.客户端要么使用Creator对象，要么使用Creator创建的对象，一般不直接使用工厂方法。
 *  IoC/DI
 *      概念：
 *          1）依赖注入：应用程序依赖于容器创建并注入应用程序所需要的外部资源。
 *          2）控制反转：容器控制应用程序，由容器反向地向应用程序注入其所需的外部资源。
 *      理解：
 *          引入IoC/DI后，应用程序被动等待Ioc/DI容器获取资源实例，再反向注入到应用程序中。
 *      思想：
 *          “主从换位”，应用程序从老大--->被动等待IoC/DI容器创建并注入；
 *          是编程思想的一大进步，有效分离了对象及其所需资源，使得松散耦合，功能复用，程序的体系结构变得灵活。
 *      关系：
 *          工厂方法模式与IoC/DI思想类似，均为“主动变被动”，进行主从换位。
 *  平行的类层次结构
 *  参数化工厂方法
 *  优点：
 *      1）可在不知道具体实现的情况下编程
 *      2）更易扩展对象的新版本
 *      3）连接平行的类层次
 *      4）具体产品对象与工厂方法的耦合性
 *  本质：延迟到子类选择实现
 *  设计原则：“依赖倒置原则”--->依赖于抽象，而不依赖于具体类
 *  使用场景：
 *      1）若一个类需要创建某个接口的对象，但不知道具体实现，可选用此模式。
 *      2）若一个类本身就希望其子类创建所需的对象，可选用此模式。
 */
public abstract class Creator {

    /**
     * 一般不对外
     * 创建Product对象的工厂方法
     */
    protected abstract Product factoryMethod();

    /**
     * 示意方法
     */
    public void someOperation() {
        // 调用工厂方法获取Product对象
        Product product = factoryMethod();
    }

}
