package cn.edu.bupt.opensource.example;

/**
 * <p>Title: Builder</p>
 * <p>Description: 构建器接口 </p>
 * <p>Company: bupt.edu.cn</p>
 * <p>Created: 2018-06-26 12:10</p>
 * @author ChengTengfei
 * @version 1.0
 *
 * 生成器模式(建造模式)
 *  定义：将一个复杂对象的构建与表示分离，即抽象化，使得同样的构建过程可实现不同的表示。
 *  角色：
 *      1）Builder：生成器接口，定义一个创建Product对象所需的各个部件的操作。
 *              即定义如何构建各个部件，知道每个部件的功能如何实现、及如何装配到Product中。（重在微观）
 *      2）ConcreteBuilder：具体的生成器实现，实现Product对象各个部件的构建与组装，同时对外提供一个获取组装后产品对象的方法。
 *      3）Director：指导者/导向者，使用Builder接口，以一个统一的过程来构建所需要的Product对象。
 *              知道如何组合来构建产品，即Director负责整体的构建算法，且通常分步骤来执行。（重在宏观）
 *      4）Product：产品，表示被生成器构建的复杂对象，包含多个部件。
 *  举例：导出数据的应用框架(继续篇)
 *      1）通常具体的导出内容与格式是有要求的，如下：
 *          A.导出的文件分为三部分：文件头、文件体、文件尾
 *          B.文件头信息：分公司编号、导出数据日期；文本文件使用逗号分隔
 *          C.文件体信息：表名称，然后分条描述数据。表名占一行，数据描述一行为一条记录，字段间使用逗号分隔。
 *          D.文件尾信息：输出人
 *      2）不使用模式
 *          A.处理步骤相同，但每一步的具体实现不同。   拼接文件头---拼接文件体---拼接文件尾---输出文件
 *          B.问题：
 *              当构建每种输出格式的文件内容时，均重复上述步骤，所以应提炼出来形成公共的处理过程。
 *              要求在处理过程不变时，方便地切换不同的输出格式。
 *  理解：
 *      1）功能：细化地、分步骤地构建复杂的产品，即重在解决一步一步构建复杂对象的问题。
 *              最重要的，构建的过程是统一的、固定不变的；变化的部分放在具体的生成器中，仅配置不同的生成器实现，即可构建不同的产品。
 *      2）重心：分离构建算法(Director)、具体的构建实现(Builder)！
 *      3）因此，生成器模式的构成包括：
 *          A.部件构造与产品装配
 *          B.整体构建的算法
 *      4）使用：客户端创建Director，在Director里封装整体构建算法，然后调用Builder，让Builder封装具体部件的构造功能。
 *  理解：
 *      1）生成器的实现
 *          A.在Builder接口的实现中，每个部件构建方法中包含：1)创建部件对象，2)组装部件
 *          B.部件对象的创建可结合简单工厂、或工厂方法模式。
 *          C.若Builder实现无组装功能，则类似于抽象工厂，但不符合设计目的。
 *      2）指导者的实现
 *          A.承担整体的构建算法，是相对不变的部分。
 *          B.一般具有较复杂的算法、运算过程，仅有部分代码需要调用生成器的方法来构建部件。
 *      3）交互
 *          A.通过生成器的buildPart方法进行交互
 *      4）注意：在标准的生成器模式中，一般不需要对Product定义抽象接口，因为最终构造的Product千差万别。
 *  优点：
 *      1）松散耦合
 *      2）易于改变产品的内部表示
 *      3）复用性好
 *  本质：整体构建算法与部件构造的分离
 *  适用场景：
 *      1）若创建对象的算法，独立于该对象的组成部分、及装配方式，可考虑。
 *      2）若同一个构建过程具有不同的表示，可考虑。
 */
public interface Builder {

    /**
     * 构建某个部件
     */
    void buildPart();

}
